diff --git a/simso/configuration/Configuration.py b/simso/configuration/Configuration.py
index 4c0f2d7..899d85f 100644
--- a/simso/configuration/Configuration.py
+++ b/simso/configuration/Configuration.py
@@ -277,22 +277,24 @@ class Configuration(object):
         """
         return self._scheduler_info
 
-    def add_task(self, name, identifier, task_type="Periodic",
+    def add_task(self, name, identifier, task_class="Generic", task_type="Periodic",
                  abort_on_miss=True, period=10, activation_date=0,
                  n_instr=0, mix=0.5, stack_file="", wcet=0, acet=0,
                  et_stddev=0, deadline=10, base_cpi=1.0, followed_by=None,
-                 list_activation_dates=[], preemption_cost=0, data=None):
+                 list_activation_dates=[], preemption_cost=0, nr_crit_levels=1,
+                 crit_level=0, list_wcets=[], wcet_deviations=[], data=None):
         """
         Helper method to create a TaskInfo and add it to the list of tasks.
         """
         if data is None:
             data = dict((k, None) for k in self.task_data_fields)
 
-        task = TaskInfo(name, identifier, task_type, abort_on_miss, period,
-                        activation_date, n_instr, mix,
+        task = TaskInfo(name, identifier, task_class, task_type, abort_on_miss,
+                        period, activation_date, n_instr, mix,
                         (stack_file, self.cur_dir), wcet, acet, et_stddev,
                         deadline, base_cpi, followed_by, list_activation_dates,
-                        preemption_cost, data)
+                        preemption_cost, nr_crit_levels, crit_level, list_wcets,
+                        wcet_deviations, data)
         self.task_info_list.append(task)
         return task
 
diff --git a/simso/core/Job.py b/simso/core/Job.py
index 4708fd3..0fc6626 100644
--- a/simso/core/Job.py
+++ b/simso/core/Job.py
@@ -277,6 +277,13 @@ class Job(Process):
         """
         return self._task.deadline
 
+    @deadline.setter
+    def deadline(self, value):
+        """
+        Set deadline
+        """
+        self._task.deadline = value
+
     @property
     def pred(self):
         return self._pred
diff --git a/simso/core/Task.py b/simso/core/Task.py
index da5ad2d..beca41d 100644
--- a/simso/core/Task.py
+++ b/simso/core/Task.py
@@ -17,10 +17,11 @@ class TaskInfo(object):
     :class:`Task` instances can be created.
     """
 
-    def __init__(self, name, identifier, task_type, abort_on_miss, period,
+    def __init__(self, name, identifier, task_class, task_type, abort_on_miss, period,
                  activation_date, n_instr, mix, stack_file, wcet, acet,
                  et_stddev, deadline, base_cpi, followed_by,
-                 list_activation_dates, preemption_cost, data):
+                 list_activation_dates, preemption_cost, nr_crit_levels,
+                 crit_level, list_wcets, wcet_deviations, data):
         """
         :type name: str
         :type identifier: int
@@ -39,10 +40,12 @@ class TaskInfo(object):
         :type followed_by: int
         :type list_activation_dates: list
         :type preemption_cost: int
+        :type nr_crit_levels: int
         :type data: dict
         """
         self.name = name
         self.identifier = identifier
+        self.task_class = task_class
         self.task_type = task_type
         self.period = period
         self.activation_date = activation_date
@@ -62,6 +65,10 @@ class TaskInfo(object):
         self.list_activation_dates = list_activation_dates
         self.data = data
         self.preemption_cost = preemption_cost
+        self.nr_crit_levels = nr_crit_levels
+        self.crit_level = crit_level
+        self.list_wcets = list_wcets
+        self.wcet_deviations = wcet_deviations
 
     @property
     def csdp(self):
@@ -141,6 +148,7 @@ class GenericTask(Process):
         self._cpi_alone = {}
         self._jobs = []
         self.job = None
+        self.enabled = True
 
     def __lt__(self, other):
         return self.identifier < other.identifier
@@ -156,6 +164,10 @@ class GenericTask(Process):
             proc = self.cpu
         return self._cpi_alone[proc]
 
+    @property
+    def task_class(self):
+        return self._task_info.task_class
+
     @property
     def base_cpi(self):
         return self._task_info.base_cpi
@@ -174,6 +186,13 @@ class GenericTask(Process):
         """
         return self._task_info.deadline
 
+    @deadline.setter
+    def deadline(self, value):
+        """
+        Set deadline
+        """
+        self._task_info.deadline = value
+
     @property
     def n_instr(self):
         return self._task_info.n_instr
@@ -190,6 +209,22 @@ class GenericTask(Process):
     def preemption_cost(self):
         return self._task_info.preemption_cost
 
+    @property
+    def nr_crit_levels(self):
+        return self._task_info.nr_crit_levels
+
+    @property
+    def crit_level(self):
+        return self._task_info.crit_level
+
+    @property
+    def list_wcets(self):
+        return self._task_info.list_wcets
+
+    @property
+    def wcet_deviations(self):
+        return self._task_info.wcet_deviations
+
     @property
     def footprint(self):
         return int(self._task_info.n_instr * self._task_info.mix *
@@ -261,7 +296,10 @@ class GenericTask(Process):
             self.sim.activate(self.job, self.job.activate_job())
 
     def _job_killer(self, job):
-        if job.end_date is None and job.computation_time < job.wcet:
+        if job.end_date is None and (
+                job.computation_time < job.wcet or
+                job.computation_time < job.deadline
+        ):
             if self._task_info.abort_on_miss:
                 self.cancel(job)
                 job.abort()
@@ -316,7 +354,7 @@ class PTask(GenericTask):
                               self._sim.cycles_per_ms)
 
         while True:
-            #print self.sim.now(), "activate", self.name
+            # print self.sim.now(), "activate", self.name
             self.create_job()
             yield hold, self, int(self.period * self._sim.cycles_per_ms)
 
@@ -329,11 +367,66 @@ class SporadicTask(GenericTask):
     fields = ['list_activation_dates', 'deadline', 'wcet']
 
     def execute(self):
+        self._init()
+        for ndate in self.list_activation_dates:
+            yield hold, self, int(ndate * self._sim.cycles_per_ms) \
+                              - self._sim.now()
+            self.create_job()
+
+    @property
+    def list_activation_dates(self):
+        return self._task_info.list_activation_dates
+
+
+class MixedCriticalityTask(GenericTask):
+    """
+        Mixed criticality abstract class. Inherits from :class:`GenericTask`.
+    """
+    fields = ['deadline', 'wcet', 'nr_crit_levels', 'crit_level', 'list_wcets', 'wcet_deviations']
+
+
+class MCATask(MixedCriticalityTask):
+    """
+        Non-periodic Task process. Inherits from :class:`Mixed-Criticality`. The job is
+        created by another task.
+        """
+
+    def execute(self):
+        self._init()
+        yield passivate, self
+
+
+class MCPTask(MixedCriticalityTask):
+    """
+    Periodic Task process. Inherits from :class:`Mixed-Criticality`. The jobs are
+    created periodically.
+    """
+    fields = MixedCriticalityTask.fields + ['activation_date', 'period']
+
+    def execute(self):
+        self._init()
+        # wait the activation date.
+        yield hold, self, int(self._task_info.activation_date *
+                              self._sim.cycles_per_ms)
 
+        while True and self.enabled:
+            # print self.sim.now(), "activate", self.name
+            self.create_job()
+            yield hold, self, int(self.period * self._sim.cycles_per_ms)
+
+
+class MCSporadicTask(MixedCriticalityTask):
+    """
+        Sporadic Task process. Inherits from :class:`Mixed-Criticality`. The jobs are
+        created using a list of activation dates.
+    """
+    fields = MixedCriticalityTask.fields + ['list_activation_dates']
+
+    def execute(self):
         self._init()
         for ndate in self.list_activation_dates:
             yield hold, self, int(ndate * self._sim.cycles_per_ms) \
-                - self._sim.now()
+                              - self._sim.now()
             self.create_job()
 
     @property
@@ -342,9 +435,16 @@ class SporadicTask(GenericTask):
 
 
 task_types = {
-    "Periodic": PTask,
-    "APeriodic": ATask,
-    "Sporadic": SporadicTask
+    "Generic": {
+        "Periodic": PTask,
+        "APeriodic": ATask,
+        "Sporadic": SporadicTask
+    },
+    "Mixed-Criticality": {
+        "Periodic": MCPTask,
+        "APeriodic": MCATask,
+        "Sporadic": MCSporadicTask
+    }
 }
 
 task_types_names = ["Periodic", "APeriodic", "Sporadic"]
@@ -356,4 +456,4 @@ def Task(sim, task_info):
     task_info.
     """
 
-    return task_types[task_info.task_type](sim, task_info)
+    return task_types[task_info.task_class][task_info.task_type](sim, task_info)
diff --git a/simso/core/etm/WCET.py b/simso/core/etm/WCET.py
index afaa37f..d318eeb 100644
--- a/simso/core/etm/WCET.py
+++ b/simso/core/etm/WCET.py
@@ -5,6 +5,7 @@ from simso.core.etm.AbstractExecutionTimeModel \
 class WCET(AbstractExecutionTimeModel):
     def __init__(self, sim, _):
         self.sim = sim
+        self.et = {}
         self.executed = {}
         self.on_execute_date = {}
 
@@ -20,7 +21,7 @@ class WCET(AbstractExecutionTimeModel):
 
     def on_activate(self, job):
         self.executed[job] = 0
-
+        self.et[job] = job.wcet * self.sim.cycles_per_ms
     def on_execute(self, job):
         self.on_execute_date[job] = self.sim.now()
 
@@ -29,9 +30,11 @@ class WCET(AbstractExecutionTimeModel):
 
     def on_terminated(self, job):
         self.update_executed(job)
+        del self.et[job]
 
     def on_abort(self, job):
         self.update_executed(job)
+        del self.et[job]
 
     def get_executed(self, job):
         if job in self.on_execute_date:
@@ -41,8 +44,7 @@ class WCET(AbstractExecutionTimeModel):
         return self.executed[job] + c
 
     def get_ret(self, job):
-        wcet_cycles = int(job.wcet * self.sim.cycles_per_ms)
-        return int(wcet_cycles - self.get_executed(job))
+        return int(self.et[job] - self.get_executed(job))
 
     def update(self):
         for job in list(self.on_execute_date.keys()):
diff --git a/simso/generator/task_generator.py b/simso/generator/task_generator.py
index 1fad270..5d76d86 100755
--- a/simso/generator/task_generator.py
+++ b/simso/generator/task_generator.py
@@ -236,6 +236,16 @@ def gen_arrivals(period, min_, max_, round_to_int=False):
     return dates
 
 
+def gen_list_wcets(general_wcet, nr_crit_levels, round_to_int=False):
+    wcets = []
+    for i in range(nr_crit_levels):
+        wcet = general_wcet + 0.01 * general_wcet * i
+        if round_to_int:
+            wcet = int(round(wcet))
+        wcets.append(wcet)
+    return wcets
+
+
 def gen_periods_loguniform(n, nsets, min_, max_, round_to_int=False):
     """
     Generate a list of `nsets` sets containing each `n` random periods using a
